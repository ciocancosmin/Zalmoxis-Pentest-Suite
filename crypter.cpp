#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>
#include<iostream>

#ifndef CRYPTER_H
#include "crypter.h"
#endif

crypter::crypter()
{
	srand((unsigned) time(0));
	crypted_message_buffer = (char*)malloc(100);
	crypted_message_buffer_key = (char*)malloc(100);
	random_message_buffer = (char*)malloc(2);
}

crypter::~crypter()
{
	//printf("crypter class destroyer called!\n");
	free(crypted_message_buffer);
	free(crypted_message_buffer_key);
	free(random_message_buffer);
}

int crypter::generate_random_nr(int low, int high)
{
	int return_nr = low + ( rand() % (high - low) );
	return return_nr;
}
int crypter::generate_random_nr_even(int low, int high, int even)
{
	bool still_choosing = 1;
	int return_nr;
	while( still_choosing )
	{
		int random_nr = this->generate_random_nr(low,high);
		if( (even && random_nr % 2 == 0) || (!even && random_nr % 2 != 0) )
		{
			still_choosing = 0;
			return_nr = random_nr;
		}
	}
	return return_nr;
}

void crypter::test_function()
{
	printf("let's have fun!\n");
}

crypter_struct crypter::crypt_message(char * plain_text_message)
{

	crypter_struct return_cs;
	int message_to_be_encrypted_length = strlen(plain_text_message);
	int x = 0;
	int s = 0;

	this->crypted_message_buffer_key = (char*)realloc(this->crypted_message_buffer_key, 34 * message_to_be_encrypted_length * 10 );
	this->crypted_message_buffer = (char*)realloc(this->crypted_message_buffer, 50 * message_to_be_encrypted_length * 10 );

	strcpy(this->crypted_message_buffer_key,"");

	//generating encypted key
	while(x < message_to_be_encrypted_length)
	{
		int chunk_length = this->generate_random_nr( 25 , 50 );
		int target_char_location = this->generate_random_nr( 0, chunk_length - 3 );
		int ascii_char_offset = this->generate_random_nr( 0 , 20 );
		int how_many_to_jump = this->generate_random_nr( 15 , 30 );

		//ascii offset values
		int chunk_length_offset = 8;
		int target_char_location_offset = 33;
		int ascii_char_offset_offset = 33;
		int how_many_to_jump_offset = 18;

		//printf("%d %d %d %d\n", chunk_length, target_char_location, ascii_char_offset, how_many_to_jump);

		if( chunk_length % 2 == 0 ) x++;

		chunk_length += chunk_length_offset;
		target_char_location += target_char_location_offset;
		ascii_char_offset += ascii_char_offset_offset;
		how_many_to_jump += how_many_to_jump_offset;

		crypted_message_buffer_key[ s ] = chunk_length;
		s++;
		crypted_message_buffer_key[ s ] = target_char_location;
		s++;
		crypted_message_buffer_key[ s ] = ascii_char_offset;
		s++;
		crypted_message_buffer_key[ s ] = how_many_to_jump;
		s++;

		for(int i=0;i<how_many_to_jump - how_many_to_jump_offset;i++)
		{
			crypted_message_buffer_key[ s ] = this->generate_random_nr(33,126);
			s++;
		}

		//printf("%c %c %c %c\n", chunk_length, target_char_location, ascii_char_offset, how_many_to_jump);

	}

	crypted_message_buffer_key[s] = '\0';

	//printf("%s\n", this->crypted_message_buffer_key);

	//printf("%d\n", int( this->crypted_message_buffer_key[0] ) - 8);

	x = 0;
	s = 0;
	int chunk_cnt = 0;
	int j = 0;

	while(x < strlen(this->crypted_message_buffer_key) )
	{

		//ascii offset values
		int chunk_length_offset = 8;
		int target_char_location_offset = 33;
		int ascii_char_offset_offset = 33;
		int how_many_to_jump_offset = 18;

		//going through the key and building the crypted message following the indications, also decoding the values from characters
		int crpyted_chunk_length = int(this->crypted_message_buffer_key[x]) - chunk_length_offset;
		int crpyted_target_char_location = int(this->crypted_message_buffer_key[x+1]) - target_char_location_offset;
		int crypted_ascii_char_offset = int(this->crypted_message_buffer_key[x+2]) - ascii_char_offset_offset;
		int crypted_how_many_to_jump = int(this->crypted_message_buffer_key[x+3]) - how_many_to_jump_offset;

		//building the crypted message
		for(int i=0;i<crpyted_chunk_length;i++)
		{
			this->crypted_message_buffer[s] = this->generate_random_nr(33,126);
			s++;
		}

		if(crpyted_chunk_length % 2 == 0)
		{
			if( int(plain_text_message[j]) + crypted_ascii_char_offset < 126 )
			{
				this->crypted_message_buffer[ chunk_cnt + crpyted_target_char_location ] = int(plain_text_message[j]) + crypted_ascii_char_offset;
				this->crypted_message_buffer[ chunk_cnt + crpyted_target_char_location + 1 ] = this->generate_random_nr_even(33,126,1);
			}
			else
			{
				this->crypted_message_buffer[ chunk_cnt + crpyted_target_char_location ] = int(plain_text_message[j]) - crypted_ascii_char_offset;
				this->crypted_message_buffer[ chunk_cnt + crpyted_target_char_location + 1 ] = this->generate_random_nr_even(33,126,0);
			}
			j++;
		}

		//printf("%d %d %d %d\n", crpyted_chunk_length, crpyted_target_char_location, crypted_ascii_char_offset, crypted_how_many_to_jump);

		//jumping to next chunk
		x += (crypted_how_many_to_jump + 1) + 3;
		chunk_cnt += crpyted_chunk_length;
	
	}

	this->crypted_message_buffer[s] = '\0';

	//printf("\n");

	//printf("%s\n", this->crypted_message_buffer);

	return_cs.encrypted_message = this->crypted_message_buffer;
	return_cs.message_key = this->crypted_message_buffer_key;

	return return_cs;

	//printf("%d\n", x);

}

char * crypter::decrypt_message(crypter_struct cs)
{
	random_message_buffer = (char*)realloc(random_message_buffer, strlen(cs.encrypted_message) );

	//printf("\n%s\n\n%s\n", cs.message_key, cs.encrypted_message);

	int x = 0;
	int s = 0;
	int chunk_cnt = 0;

	//ascii offset values
	int chunk_length_offset = 8;
	int target_char_location_offset = 33;
	int ascii_char_offset_offset = 33;
	int how_many_to_jump_offset = 18;

	while( x < strlen(cs.message_key) )
	{

		int chunk_length = cs.message_key[x];
		int target_char_location = cs.message_key[x+1];
		int ascii_char_offset = cs.message_key[x+2];
		int how_many_to_jump = cs.message_key[x+3];

		chunk_length -= chunk_length_offset;
		target_char_location -= target_char_location_offset;
		ascii_char_offset -= ascii_char_offset_offset;
		how_many_to_jump -= how_many_to_jump_offset;

		if( chunk_length % 2 == 0 ){
			if( int( cs.encrypted_message[ chunk_cnt + target_char_location + 1 ] ) % 2 == 0 ) random_message_buffer[s] = int( cs.encrypted_message[ chunk_cnt + target_char_location ] ) - ascii_char_offset;
			else if( int( cs.encrypted_message[ chunk_cnt + target_char_location + 1 ] ) % 2 != 0 ) random_message_buffer[s] = int( cs.encrypted_message[ chunk_cnt + target_char_location ] ) + ascii_char_offset;
			s++;
		}

		//jumping to the next chunk
		x += (how_many_to_jump + 1) + 3;
		chunk_cnt += chunk_length;

	}

	random_message_buffer[s] = '\0';

	printf("%s\n\n%s\n", cs.encrypted_message, cs.message_key );

	return random_message_buffer;
}

/*int main(int argc, char const *argv[])
{
	
	crypter crpt;
	crypter_struct test_cs;

	char * test_char_buff = (char*)malloc(100);

	strcpy(test_char_buff,"mama are mere");

	test_cs = crpt.crypt_message( test_char_buff );

	test_char_buff = crpt.decrypt_message( test_cs );

	printf("%s\n", test_char_buff);

	return 0;
}*/